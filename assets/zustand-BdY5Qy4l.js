import{W as y,A as x}from"./react-PeVXrSQc.js";function H(t,n){let e;try{e=t()}catch{return}return{getItem:a=>{var s;const f=d=>d===null?null:JSON.parse(d,void 0),u=(s=e.getItem(a))!=null?s:null;return u instanceof Promise?u.then(f):f(u)},setItem:(a,s)=>e.setItem(a,JSON.stringify(s,void 0)),removeItem:a=>e.removeItem(a)}}const p=t=>n=>{try{const e=t(n);return e instanceof Promise?e:{then(r){return p(r)(e)},catch(r){return this}}}catch(e){return{then(r){return this},catch(r){return p(r)(e)}}}},k=(t,n)=>(e,r,a)=>{let s={storage:H(()=>localStorage),partialize:o=>o,version:0,merge:(o,v)=>({...v,...o}),...n},f=!1;const u=new Set,d=new Set;let i=s.storage;if(!i)return t((...o)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),e(...o)},r,a);const g=()=>{const o=s.partialize({...r()});return i.setItem(s.name,{state:o,version:s.version})},S=a.setState;a.setState=(o,v)=>(S(o,v),g());const h=t((...o)=>(e(...o),g()),r,a);a.getInitialState=()=>h;let m;const E=()=>{var o,v;if(!i)return;f=!1,u.forEach(c=>{var l;return c((l=r())!=null?l:h)});const b=((v=s.onRehydrateStorage)==null?void 0:v.call(s,(o=r())!=null?o:h))||void 0;return p(i.getItem.bind(i))(s.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==s.version){if(s.migrate){const l=s.migrate(c.state,c.version);return l instanceof Promise?l.then(I=>[!0,I]):[!0,l]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var l;const[I,j]=c;if(m=s.merge(j,(l=r())!=null?l:h),e(m,!0),I)return g()}).then(()=>{b?.(m,void 0),m=r(),f=!0,d.forEach(c=>c(m))}).catch(c=>{b?.(void 0,c)})};return a.persist={setOptions:o=>{s={...s,...o},o.storage&&(i=o.storage)},clearStorage:()=>{i?.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>E(),hasHydrated:()=>f,onHydrate:o=>(u.add(o),()=>{u.delete(o)}),onFinishHydration:o=>(d.add(o),()=>{d.delete(o)})},s.skipHydration||E(),m||h},P=k,F=t=>{let n;const e=new Set,r=(i,g)=>{const S=typeof i=="function"?i(n):i;if(!Object.is(S,n)){const h=n;n=g??(typeof S!="object"||S===null)?S:Object.assign({},n,S),e.forEach(m=>m(n,h))}},a=()=>n,u={setState:r,getState:a,getInitialState:()=>d,subscribe:i=>(e.add(i),()=>e.delete(i))},d=n=t(r,a,u);return u},_=(t=>t?F(t):F),q=t=>t;function w(t,n=q){const e=y.useSyncExternalStore(t.subscribe,y.useCallback(()=>n(t.getState()),[t,n]),y.useCallback(()=>n(t.getInitialState()),[t,n]));return y.useDebugValue(e),e}const O=t=>{const n=_(t),e=r=>w(n,r);return Object.assign(e,n),e},B=(t=>t?O(t):O),{useSyncExternalStoreWithSelector:R}=x,C=t=>t;function J(t,n=C,e){const r=R(t.subscribe,t.getState,t.getInitialState,n,e);return y.useDebugValue(r),r}const W=(t,n)=>{const e=_(t),r=(a,s=n)=>J(e,a,s);return Object.assign(r,e),r},D=((t,n)=>t?W(t,n):W);export{B as a,H as b,D as c,P as p};
